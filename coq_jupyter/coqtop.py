from __future__ import unicode_literals

import pexpect
import re

import xml.etree.ElementTree as ET
from future.utils import raise_with_traceback
from collections import deque


INIT_COMMAND = '<call val="Init"> <option val="none"/> </call>'
STATUS_COMMAND = '<call val="Status"> <bool val="true"/> </call>'
GOAL_COMMAND = '<call val="Goal"> <unit/> </call>'

ADD_COMMAND_TEMPLATE = """
<call val="Add">
  <pair>
    <pair> <string>{0}</string> <int>0</int> </pair>
    <pair> <state_id val="{1}" /> <bool val="true" /> </pair>
  </pair>
</call>
"""

EDIT_AT_COMMAND_TEMPLATE = '<call val="Edit_at"> <state_id val="{0}"/> </call>'

REPLY_PATTERNS = [
    re.compile(r'\<{0}.*?\>.+?\<\/{0}\>'.format(t), re.DOTALL)
    for t in [
        "feedback",
        "value",
        "message" # older versions of coqtop wont wrap 'message' inside 'feedback'
    ]
]

class CoqtopError(Exception): pass

class CoqtopWrapper:

    def __init__(self, kernel, coqtop_args):
        try:
            self.log = kernel.log
            self._coqtop = pexpect.spawn(
                "coqtop -toploop coqidetop -main-channel stdfds {}".format(coqtop_args),
                echo=False,
                encoding="utf-8",
                codec_errors="replace"
            )

            (reply, _) = self._execute_command(INIT_COMMAND)
            self._tip = reply.find("state_id").get("val")

        except Exception as e:
            raise_with_traceback(CoqtopError("Cause: {}".format(repr(e))))

    def eval(self, code):
        try:
            tip_before = self._tip

            # split code into sentences (headlesssly)
            sentences = code.split(".")
            leftover = sentences[-1]
            sentences = deque(map(lambda s: s + ".", sentences[0:-1]))
            if leftover.strip(" \t\n\r") != "":
                sentences.append(leftover)

            # Attempt to evaluate sentences in code
            evaluated = True
            outputs = []
            while len(sentences) > 0:
                sentence = sentences.popleft()

                (reply, _) = self._execute_command(ADD_COMMAND_TEMPLATE.format(sentence, self._tip), allow_fail=True)

                if not self._is_good(reply) and len(sentences) > 0:
                    # Attempt to fix error by joining erroneus sentence with next one.
                    # This should fix any errors caused by headless splitting
                    # of code into sentences
                    sentences.appendleft(sentence + sentences.popleft())
                    continue

                if not self._is_good(reply) and len(sentences) == 0 and self._is_end_of_input_error(reply):
                    # It is ok to ignore failute and output generated by evaluating
                    # 'effectively empty' leftover sentence
                    break

                if not self._is_good(reply) and len(sentences) == 0:
                    # Upon reaching this state it we can definitely say that there is
                    # some error in cell code
                    evaluated = False
                    outputs.append(self._get_error_content(reply))
                    break

                self._tip = reply.find("pair").find("state_id").get("val")

                (_, extra_status_replies) = self._execute_command(STATUS_COMMAND)

                outputs.extend([
                    self._get_message_content(r)
                    for r in extra_status_replies
                    if self._is_message(r)
                ])

            if evaluated:
                # Get data about theorem being proven
                (status_reply, _) = self._execute_command(STATUS_COMMAND)
                if self._is_proving(status_reply):
                    outputs.append("Proving: {}".format(self._get_proof_name(status_reply)))

                # Get goal state
                (goal_reply, _) = self._execute_command(GOAL_COMMAND)
                if self._has_goals(goal_reply):
                    outputs.append(self._get_goals_content(goal_reply))
            else:
                # roll back any side effects of code
                self.roll_back_to(tip_before)

            return (self._tip, evaluated, outputs)

        except Exception as e:
            raise_with_traceback(CoqtopError("Cause: {}".format(repr(e))))

    def roll_back_to(self, state_id):
        (reply, _) = self._execute_command(EDIT_AT_COMMAND_TEMPLATE.format(state_id))
        self._tip = state_id

    def _execute_command(self, command, allow_fail=False):
        self._coqtop.send(command + "\n")
        extra_replies = []
        while True:
            self._coqtop.expect(REPLY_PATTERNS)

            if self._coqtop.before.strip(" \t\n\r") != "":
                self.log.info("Skipping unexpected coqtop output: {}".format(repr(self._coqtop.before)))

            reply = self._parse(self._coqtop.match.group(0))

            if reply.tag == "value" and not allow_fail and not self._is_good(reply):
                raise CoqtopError("Unexpected reply: {}".format(ET.tostring(reply)))
            elif reply.tag == "value":
                return (reply, extra_replies)
            else:
                extra_replies.append(reply)

    def _parse(self, reply):
        return ET.fromstring(reply.replace("&nbsp;", "&#160;"))

    def _is_good(self, reply):
        return reply.get("val") == "good"

    def _unwrap_message(self, reply):
        return reply if reply.tag == "message" else reply.find(".//message")

    def _is_message(self, reply):
        return self._unwrap_message(reply) is not None

    def _get_message_content(self, reply):
        return self._format_richpp(self._unwrap_message(reply).find("./richpp"))

    def _unwrap_goals(self, reply):
        return reply.find("./option/goals")

    def _has_goals(self, reply):
        return self._unwrap_goals(reply) is not None

    def _get_goals_content(self, reply):
        goals = self._unwrap_goals(reply)
        current_goals = list(goals.find("./list").findall("./goal"))

        if len(current_goals) == 0:
            raise CoqtopError("Expected at least 1 current goal in reply: {}".format(ET.tostring(reply)))
        elif len(current_goals) == 1:
            header_content = "1 subgoal"
        else:
            header_content = "{} subgoals".format(len(current_goals))

        hypotheses_content = "\n".join(map(self._format_richpp, current_goals[0].findall("./list/richpp")))

        goals_content = "\n".join(map(
            lambda d: "{}\n{}".format(
                "{}/{} -----------".format(d[0] + 1, len(current_goals))[0:15],
                self._format_richpp(d[1].find("./richpp"))
            ),
            enumerate(current_goals)
        ))

        return "\n\n".join(filter(lambda c: c != "", [header_content, hypotheses_content, goals_content]))

    def _is_proving(self, reply):
        return reply.find(".status/option/string") is not None

    def _get_proof_name(self, reply):
        return reply.find(".status/option/string").text

    def _get_error_content(self, reply):
        # TODO add error context using loc_s, loc_e
        return self._format_richpp(reply.find("./richpp"))

    def _format_richpp(self, richpp):
        return ET.tostring(richpp, encoding='utf8', method='text').decode('utf8')

    def _is_end_of_input_error(self, reply):
        error_content = self._get_error_content(reply)
        if "Anomaly" in error_content and "Stm.End_of_input" in error_content:
            return True
        elif "Anomaly" in error_content and 'Invalid_argument("vernac_parse")' in error_content: # for older versions
            return True
        else:
            return False
